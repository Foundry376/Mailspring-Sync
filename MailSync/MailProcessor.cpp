//
//  MailProcessor.cpp
//  MailSync
//
//  Created by Ben Gotow on 6/20/17.
//  Copyright Â© 2017 Foundry 376. All rights reserved.
//

#include "MailProcessor.hpp"
#include "MailUtils.hpp"

using namespace std;
using nlohmann::json;

MailProcessor::MailProcessor(MailStore * store) :
    store(store),
    logger(spdlog::stdout_color_mt("processor"))
{

}

void MailProcessor::insertMessage(IMAPMessage * mMsg, Folder & folder) {
    Message msg(mMsg, folder);

    logger->info("ðŸ”¹ Inserting message with subject: {}", msg.subject());

    // first, find or build a thread for this message
    Array * references = mMsg->header()->references();
    if (references == nullptr) {
        references = new Array();
        references->autorelease();
    }
    shared_ptr<Thread> thread;
    auto allLabels = store->allLabelsCache();

    store->beginTransaction();

    if (mMsg->gmailThreadID()) {
        Query query = Query().equal("gThrId", to_string(mMsg->gmailThreadID()));
        thread = store->find<Thread>(query);
        
    } else if (!mMsg->header()->isMessageIDAutoGenerated()) {
        // find an existing thread using the references
        SQLite::Statement tQuery(store->db(), "SELECT Thread.* FROM Thread INNER JOIN ThreadReference ON ThreadReference.threadId = Thread.id WHERE ThreadReference.headerMessageId IN (" + MailUtils::qmarks(1 + references->count()) + ") LIMIT 1");
        tQuery.bind(1, msg.headerMessageId());
        for (int i = 0; i < references->count(); i ++) {
            String * ref = (String *)references->objectAtIndex(i);
            tQuery.bind(2 + i, ref->UTF8Characters());
        }
        if (tQuery.executeStep()) {
            thread = make_shared<Thread>(tQuery);
        }
    }
    
    if (thread != nullptr) {
        thread->addMessage(&msg, allLabels);
        store->save(thread.get());
    } else {
        thread = make_shared<Thread>(msg, mMsg->gmailThreadID(), allLabels);
        store->save(thread.get());
    }
    
    upsertThreadReferences(thread->id(), msg.headerMessageId(), references);
    
    msg.setThreadId(thread->id());
    store->save(&msg);

    store->commitTransaction();
}

// thread has many folderIds with a reference count
// when message is moved, subtract + add to folder ref counts?
// keep in JSON?

void MailProcessor::updateMessage(Message * local, IMAPMessage * remote, Folder & folder)
{
    logger->info("ðŸ”¸ Updating message with subject: {}", local->subject());

    store->beginTransaction();

    // Step 1: Find the thread
    Query query = Query().equal("id", local->threadId());
    auto thread = store->find<Thread>(query);
    auto allLabels = store->allLabelsCache();

    // Step 2: Decrement starred / unread / label counters on thread
    thread->prepareToReaddMessage(local, allLabels);
    
    // Step 3: Update the message
    auto updated = MessageAttributesForMessage(remote);
    local->setUnread(updated.unread);
    local->setStarred(updated.starred);
    local->setFolderImapUID(updated.uid);
    local->setFolder(folder);
    auto jlabels = json(updated.labels);
    local->setFolderImapXGMLabels(jlabels);
    
    // Step 4: Increment starred / urnead / label counters on thread
    thread->addMessage(local, allLabels);
    
    // Step 5: Save
    store->save(local);
    store->save(thread.get());

    store->commitTransaction();
}

void MailProcessor::unlinkMessagesFromFolder(vector<shared_ptr<Message>> localMessages)
{
    // TODO Unloop
    auto allLabels = store->allLabelsCache();
    Folder gone("--none--", "", 0);
    
    vector<string> threadIds{};
    for (const auto local : localMessages) {
        threadIds.push_back(local->threadId());
    }
    
    auto q = Query().equal("id", threadIds);
    auto threads = store->findAllMap<Thread>(q, "id");

    for (const auto local : localMessages) {
        // Step 1: Find the thread
        Thread * thread = nullptr;
        if (threads.count(local->threadId())) {
            thread = threads[local->threadId()].get();
        }

        // Step 2: Decrement starred / unread / label counters on thread
        if (thread) { thread->prepareToReaddMessage(local.get(), allLabels); }

        local->setFolderImapUID(0);
        local->setFolder(gone);

        // Step 4: Increment starred / urnead / label counters on thread
        if (thread) { thread->addMessage(local.get(), allLabels); }
        
        // Step 5: Save
        store->save(local.get());

        if (thread) { store->save(thread); }
    }
}

void MailProcessor::upsertThreadReferences(string threadId, string headerMessageId, mailcore::Array * references) {
    string qmarks(MailUtils::qmarkSets(1 + references->count(), 2));
    SQLite::Statement query(store->db(), "INSERT OR IGNORE INTO ThreadReference (threadId, headerMessageId) VALUES " + qmarks);
    int x = 1;
    query.bind(x++, threadId);
    query.bind(x++, headerMessageId);
    for (int i = 0; i < references->count(); i ++) {
        mailcore::String * address = (mailcore::String*)references->objectAtIndex(i);
        query.bind(x++, threadId);
        query.bind(x++, address->UTF8Characters());
    }
    query.exec();
}
