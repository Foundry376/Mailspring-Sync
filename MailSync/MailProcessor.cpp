//
//  MailProcessor.cpp
//  MailSync
//
//  Created by Ben Gotow on 6/20/17.
//  Copyright Â© 2017 Foundry 376. All rights reserved.
//

#include "MailProcessor.hpp"
#include "MailUtils.hpp"
#include "File.hpp"
#include "constants.h"

using namespace std;
using nlohmann::json;


MailProcessor::MailProcessor(shared_ptr<Account> account, MailStore * store) :
    store(store),
    account(account),
    logger(spdlog::get("processor"))
{

}

void MailProcessor::insertFallbackToUpdateMessage(IMAPMessage * mMsg, Folder & folder, time_t syncDataTimestamp) {
    try {
        insertMessage(mMsg, folder, syncDataTimestamp);
    } catch (const SQLite::Exception & ex) {
        if (ex.getErrorCode() != 19) { // constraint failed
            throw;
        }
        store->rollbackTransaction();
        Query q = Query().equal("id", MailUtils::idForMessage(folder.accountId(), mMsg));
        auto localMessage = store->find<Message>(q);
        if (localMessage.get() == nullptr) {
            throw;
        }
        updateMessage(localMessage.get(), mMsg, folder, syncDataTimestamp);
    }
}

void MailProcessor::insertMessage(IMAPMessage * mMsg, Folder & folder, time_t syncDataTimestamp) {
    Message msg(mMsg, folder, syncDataTimestamp);

    Array * references = mMsg->header()->references();
    if (references == nullptr) {
        references = new Array();
        references->autorelease();
    }
    shared_ptr<Thread> thread;
    auto allLabels = store->allLabelsCache(account->id());

    store->beginTransaction();

    // Find the correct thread

    if (mMsg->gmailThreadID()) {
        Query query = Query().equal("gThrId", to_string(mMsg->gmailThreadID()));
        thread = store->find<Thread>(query);
        
    } else if (!mMsg->header()->isMessageIDAutoGenerated()) {
        // find an existing thread using the references
        SQLite::Statement tQuery(store->db(), "SELECT Thread.* FROM Thread INNER JOIN ThreadReference ON ThreadReference.threadId = Thread.id WHERE ThreadReference.accountId = ? AND ThreadReference.headerMessageId IN (" + MailUtils::qmarks(1 + references->count()) + ") LIMIT 1");
        tQuery.bind(1, msg.accountId());
        tQuery.bind(2, msg.headerMessageId());
        for (int i = 0; i < references->count(); i ++) {
            String * ref = (String *)references->objectAtIndex(i);
            tQuery.bind(3 + i, ref->UTF8Characters());
        }
        if (tQuery.executeStep()) {
            thread = make_shared<Thread>(tQuery);
        }
    }
    
    // Add the message to the thread

    if (thread != nullptr) {
        thread->addMessage(&msg, allLabels);
    } else {
        thread = make_shared<Thread>(msg, mMsg->gmailThreadID(), allLabels);
    }
    
    // Apply changes to ThreadReferences, ThreadSearch, Contacts
    upsertThreadReferences(thread->id(), thread->accountId(), msg.headerMessageId(), references);
    appendToThreadSearchContent(thread.get(), &msg, nullptr);
    upsertContacts(&msg);
    
    store->save(thread.get());
    msg.setThreadId(thread->id());
    store->save(&msg);

    store->commitTransaction();
}

// thread has many folderIds with a reference count
// when message is moved, subtract + add to folder ref counts?
// keep in JSON?

// TODO: The JS side is clearing attributes placed in the JSON by the native side. Not cool

void MailProcessor::updateMessage(Message * local, IMAPMessage * remote, Folder & folder, time_t syncDataTimestamp)
{
    if (local->syncedAt() > syncDataTimestamp) {
        logger->warn("Ignoring changes to {}, more recent data is available {} < {}", local->subject(), syncDataTimestamp, local->syncedAt());
        return;
    }
    logger->info("ðŸ”¸ Updating message {}={} with subject: {}", local->remoteUID(), remote->uid(), local->subject());
    
    store->beginTransaction();

    // Step 1: Find the thread
    Query query = Query().equal("id", local->threadId());
    auto thread = store->find<Thread>(query);
    auto allLabels = store->allLabelsCache(account->id());

    // Step 2: Decrement starred / unread / label counters on thread
    thread->prepareToReaddMessage(local, allLabels);
    
    // Step 3: Update the message
    auto updated = MessageAttributesForMessage(remote);
    local->setUnread(updated.unread);
    local->setStarred(updated.starred);
    local->setDraft(updated.draft);
    local->setSyncedAt(syncDataTimestamp);
    local->setRemoteUID(updated.uid);
    local->setRemoteFolder(folder);
    local->setClientFolder(folder);
    auto jlabels = json(updated.labels);
    local->setRemoteXGMLabels(jlabels);
    
    // Step 4: Increment starred / urnead / label counters on thread
    thread->addMessage(local, allLabels);
    
    // Step 5: Save
    store->save(local);
    store->save(thread.get());

    // Step 6: Update categories listed in the FTS5 table
    appendToThreadSearchContent(thread.get(), nullptr, nullptr);
    
    store->commitTransaction();
}

void MailProcessor::retrievedMessageBody(Message * message, MessageParser * parser) {
    String * text = parser->plainTextBodyRendering(true);
    String * html = parser->htmlBodyRendering();
    
    // build file containers for the attachments and write them to disk
    Array attachments = Array();
    attachments.addObjectsFromArray(parser->attachments());
    attachments.addObjectsFromArray(parser->htmlInlineAttachments());
    
    vector<File> files;
    for (int ii = 0; ii < attachments.count(); ii ++) {
        Attachment * a = (Attachment *)attachments.objectAtIndex(ii);
        File f = File(message, a);
        
        bool duplicate = false;
        for (auto & other : files) {
            if (other.partId() == string(a->partID()->UTF8Characters())) {
                duplicate = true;
                logger->info("Attachment is duplicate: {}", f.toJSON().dump());
                break;
            }
        }
        if (!duplicate) {
            if (!retrievedFileData(&f, a->data())) {
                logger->info("Could not save file data!");
            }
            files.push_back(f);
        }
    }
    
    auto chars = html->UTF8Characters();
    
    store->beginTransaction();
    
    // write body to the MessageBodies table
    SQLite::Statement insert(store->db(), "REPLACE INTO MessageBody (id, value) VALUES (?, ?)");
    insert.bind(1, message->id());
    insert.bind(2, chars);
    insert.exec();
    
    // write files to the files table
    for (auto & file : files) {
        store->save(&file);
    }
    
    // append the body text to the thread's FTS5 search index
    auto thread = store->find<Thread>(Query().equal("id", message->threadId()));
    if (thread.get() != nullptr) {
        appendToThreadSearchContent(thread.get(), nullptr, text);
    }

    // write the message snippet. This also gives us the database trigger!
    message->setSnippet(text->substringToIndex(400)->UTF8Characters());
    message->setBodyForDispatch(chars);
    message->setFiles(files);
    
    store->save(message);
    store->commitTransaction();
}


bool MailProcessor::retrievedFileData(File * file, Data * data) {
    string path = MailUtils::pathForFile(FILES_ROOT, file, true);
    String mfilepath = String(path.c_str());
    return (data->writeToFile(&mfilepath) == ErrorNone);
}

void MailProcessor::unlinkMessagesFromFolder(Folder & folder, vector<uint32_t> & uids, int phase)
{
    logger->info("Unlinking {} messages no longer present in remote range.", uids.size());
    
    store->beginTransaction();
    
    for (vector<uint32_t> chunk : MailUtils::chunksOfVector(uids, 250)) {
        Query qd = Query().equal("remoteFolderId", folder.id()).equal("remoteUID", chunk);
        auto deletedMsgs = store->findAll<Message>(qd);

        for (const auto local : deletedMsgs) {
            local->setRemoteUID(UINT32_MAX - phase);
            store->save(local.get());
        }
    }
    
    store->commitTransaction();
}

void MailProcessor::deleteMessagesStillUnlinkedFromPhase(int phase)
{
    auto allLabels = store->allLabelsCache(account->id());
    
    store->beginTransaction();
    
    auto q = Query().equal("accountId", account->id()).equal("remoteUID", UINT32_MAX - phase);
    auto messages = store->findAll<Message>(q);
    
    map<string, bool> threadIdMap{};
    for (auto const & msg : messages) {
        threadIdMap[msg->threadId()] = true;
    }
    for (auto const & pair: threadIdMap) {
        auto tid = pair.first;
        auto thread = store->find<Thread>(Query().equal("id", tid));
        if (thread == nullptr) {
            continue;
        }

        for (const auto msg : messages) {
            if (msg->threadId() == tid) {
                thread->prepareToReaddMessage(msg.get(), allLabels);
            }
        }
        if (thread->folders().size() == 0) {
            store->remove(thread.get());
        } else {
            store->save(thread.get());
        }
    }
    
    for (const auto msg : messages) {
        store->remove(msg.get());
    }
    
    store->commitTransaction();
}

void MailProcessor::appendToThreadSearchContent(Thread * thread, Message * messageToAppendOrNull, String * bodyToAppendOrNull) {
    string categories;
    for (auto f : thread->folders()) {
        categories += ((f.count("role") ? f["role"] : f["path"]).get<string>());
        categories += " ";
    }
    for (auto f : thread->labels()) {
        categories += ((f.count("role") ? f["role"] : f["path"]).get<string>());
        categories += " ";
    }

    // retrieve the current index if there is one
    
    string to;
    string from;
    string body = thread->subject();

    if (thread->searchRowId()) {
        SQLite::Statement existing(store->db(), "SELECT to_, from_, body FROM ThreadSearch WHERE rowid = ?");
        existing.bind(1, (double)thread->searchRowId());
        if (existing.executeStep()) {
            to = existing.getColumn("to_").getString();
            from = existing.getColumn("from_").getString();
            body = existing.getColumn("body").getString();
        }
    }
    
    if (messageToAppendOrNull != nullptr) {
        for (auto c : messageToAppendOrNull->to()) {
            if (c.count("email")) { to = to + " " + c["email"].get<string>(); }
            if (c.count("name")) { to = to + " " + c["name"].get<string>(); }
        }
        for (auto c : messageToAppendOrNull->cc()) {
            if (c.count("email")) { to = to + " " + c["email"].get<string>(); }
            if (c.count("name")) { to = to + " " + c["name"].get<string>(); }
        }
        for (auto c : messageToAppendOrNull->bcc()) {
            if (c.count("email")) { to = to + " " + c["email"].get<string>(); }
            if (c.count("name")) { to = to + " " + c["name"].get<string>(); }
        }
        for (auto c : messageToAppendOrNull->from()) {
            if (c.count("email")) { from = from + " " + c["email"].get<string>(); }
            if (c.count("name")) { from = from + " " + c["name"].get<string>(); }
        }
    }
    
    if (bodyToAppendOrNull != nullptr) {
        body = body + " " + bodyToAppendOrNull->substringToIndex(5000)->UTF8Characters();
    }
    
    if (thread->searchRowId()) {
        SQLite::Statement update(store->db(), "UPDATE ThreadSearch SET to_ = ?, from_ = ?, body = ?, categories = ? WHERE rowid = ?");
        update.bind(1, to);
        update.bind(2, from);
        update.bind(3, body);
        update.bind(4, categories);
        update.bind(5, (double)thread->searchRowId());
        update.exec();
    } else {
        SQLite::Statement insert(store->db(), "INSERT INTO ThreadSearch (to_, from_, body, categories, content_id) VALUES (?, ?, ?, ?, ?)");
        insert.bind(1, to);
        insert.bind(2, from);
        insert.bind(3, body);
        insert.bind(4, categories);
        insert.bind(5, thread->id());
        insert.exec();
        thread->setSearchRowId(store->db().getLastInsertRowid());
    }
}

void MailProcessor::upsertThreadReferences(string threadId, string accountId, string headerMessageId, Array * references) {
    string qmarks(MailUtils::qmarkSets(1 + references->count(), 3));
    SQLite::Statement query(store->db(), "INSERT OR IGNORE INTO ThreadReference (threadId, accountId, headerMessageId) VALUES " + qmarks);
    int x = 1;
    query.bind(x++, threadId);
    query.bind(x++, accountId);
    query.bind(x++, headerMessageId);
    for (int i = 0; i < references->count(); i ++) {
        String * address = (String*)references->objectAtIndex(i);
        query.bind(x++, threadId);
        query.bind(x++, accountId);
        query.bind(x++, address->UTF8Characters());
    }
    query.exec();
}

void MailProcessor::upsertContacts(Message * message) {
    map<string, json> byEmail{};
    for (auto & c : message->to()) {
        if (c.count("email")) {
            byEmail[MailUtils::contactKeyForEmail(c["email"].get<string>())] = c;
        }
    }
    for (auto & c : message->cc()) {
        if (c.count("email")) {
            byEmail[MailUtils::contactKeyForEmail(c["email"].get<string>())] = c;
        }
    }
    for (auto & c : message->from()) {
        if (c.count("email")) {
            byEmail[MailUtils::contactKeyForEmail(c["email"].get<string>())] = c;
        }
    }
    
    // contactKeyForEmail returns "" for some emails. Toss out that item
    if (byEmail.count("")) {
        byEmail.erase("");
    }
    
    vector<string> emails{};
    for (auto const& imap: byEmail) {
        emails.push_back(imap.first);
    }

    if (emails.size() > 25) {
        // I think it's safe to say mass emails shouldn't create contacts.
        return;
    }

    Query query = Query().equal("email", emails);
    auto results = store->findAll<Contact>(query);
    bool incrementCounters = message->isSentByUser();
    
    for (auto & result : results) {
        // update refcounts of existing items if this is a sent message
        if (incrementCounters) {
            result->incrementRefs();
            store->save(result.get(), false);
        }
        byEmail.erase(result->email());
    }
    
    if (byEmail.size() == 0) {
        return;
    }

    SQLite::Statement searchInsert(store->db(), "INSERT INTO ContactSearch (content_id, content) VALUES (?, ?)");

    for (auto & result : byEmail) {
        // insert remaining items
        Contact c{message->accountId(), result.first, result.second};
        if (incrementCounters) {
            c.incrementRefs();
        }
        store->save(&c, false);
        
        // also index for search
        searchInsert.bind(1, c.id());
        searchInsert.bind(2, c.searchContent());
        searchInsert.exec();
        searchInsert.reset();
    }
}

