//
//  MailProcessor.cpp
//  MailSync
//
//  Created by Ben Gotow on 6/20/17.
//  Copyright Â© 2017 Foundry 376. All rights reserved.
//

#include "MailProcessor.hpp"
#include "MailStoreTransaction.hpp"
#include "MailUtils.hpp"
#include "File.hpp"
#include "constants.h"

using namespace std;
using nlohmann::json;

class CleanHTMLBodyRendererTemplateCallback : public Object, public HTMLRendererTemplateCallback {
    mailcore::String * templateForMainHeader(MessageHeader * header) {
        return MCSTR("");
    }

    mailcore::String * templateForAttachment(AbstractPart * part) {
        return MCSTR("");
    }

    mailcore::String * templateForAttachmentSeparator() {
        return MCSTR("");
    }

    // TODO: Image attachments can be added to the middle of messages
    // by putting them between two HTML parts and we can render them
    // within the body this way. However the attachments don't have cid's,
    // and the client expects to filter attachments based on whether they
    // have cids.
    
//    mailcore::String * templateForImage(AbstractPart * part) {
//        MailUtils::idForFilePart(part)
//        return MCSTR("<img src=\"{{CONTENTID}}\" data-size=\"{{SIZE}}\" data-filename=\"{{FILENAME}}\" />");
//    }
//
//    bool canPreviewPart(AbstractPart * part) {
//        string t = part->mimeType()->UTF8Characters();
//        
//        if ((t == "image/png") || (t == "image/jpeg") || (t == "image/jpg") || (t == "image/gif")) {
//            return true;
//        }
//        return false;
//    }
};


MailProcessor::MailProcessor(shared_ptr<Account> account, MailStore * store) :
    store(store),
    account(account),
    logger(spdlog::get("logger"))
{

}

shared_ptr<Message> MailProcessor::insertFallbackToUpdateMessage(IMAPMessage * mMsg, Folder & folder, time_t syncDataTimestamp) {
    try {
        return insertMessage(mMsg, folder, syncDataTimestamp);
    } catch (const SQLite::Exception & ex) {
        if (ex.getErrorCode() != 19) { // constraint failed
            throw;
        }
        Query q = Query().equal("id", MailUtils::idForMessage(folder.accountId(), mMsg));
        auto localMessage = store->find<Message>(q);
        if (localMessage.get() == nullptr) {
            throw;
        }
        updateMessage(localMessage.get(), mMsg, folder, syncDataTimestamp);
        return localMessage;
    }
}

shared_ptr<Message> MailProcessor::insertMessage(IMAPMessage * mMsg, Folder & folder, time_t syncDataTimestamp) {
    shared_ptr<Message> msg = make_shared<Message>(mMsg, folder, syncDataTimestamp);
    shared_ptr<Thread> thread = nullptr;

    Array * references = mMsg->header()->references();
    if (references == nullptr) {
        references = new Array();
        references->autorelease();
    }

    {
        MailStoreTransaction transaction{store};

        // Find the correct thread

        if (mMsg->gmailThreadID()) {
            Query query = Query().equal("gThrId", to_string(mMsg->gmailThreadID()));
            thread = store->find<Thread>(query);
            
        } else if (!mMsg->header()->isMessageIDAutoGenerated()) {
            // find an existing thread using the references
            SQLite::Statement tQuery(store->db(), "SELECT Thread.* FROM Thread INNER JOIN ThreadReference ON ThreadReference.threadId = Thread.id WHERE ThreadReference.accountId = ? AND ThreadReference.headerMessageId IN (" + MailUtils::qmarks(1 + references->count()) + ") LIMIT 1");
            tQuery.bind(1, msg->accountId());
            tQuery.bind(2, msg->headerMessageId());
            for (int i = 0; i < references->count(); i ++) {
                String * ref = (String *)references->objectAtIndex(i);
                tQuery.bind(3 + i, ref->UTF8Characters());
            }
            if (tQuery.executeStep()) {
                thread = make_shared<Thread>(tQuery);
            }
        }
        
        if (thread == nullptr) {
            // TODO: could move to message save hooks
            thread = make_shared<Thread>(msg->id(), account->id(), msg->subject(), mMsg->gmailThreadID());
        }
        
        msg->setThreadId(thread->id());

        // Index the thread metadata for search. We only do this once and it'd
        // be costly to make it part of the save hooks.
        appendToThreadSearchContent(thread.get(), msg.get(), nullptr);
        store->save(thread.get());

        // Save the message - this will automatically find and update the counters
        // on the thread we just created. Kind of a shame to find it twice but oh well.
        store->save(msg.get());
        
        // Make the thread accessible by all of the message references
        upsertThreadReferences(thread->id(), thread->accountId(), msg->headerMessageId(), references);

        // Index contacts for autocomplete
        upsertContacts(msg.get());

        transaction.commit();
    }
    
    return msg;
}

// thread has many folderIds with a reference count
// when message is moved, subtract + add to folder ref counts?
// keep in JSON?

// TODO: The JS side is clearing attributes placed in the JSON by the native side. Not cool

void MailProcessor::updateMessage(Message * local, IMAPMessage * remote, Folder & folder, time_t syncDataTimestamp)
{
    if (local->syncedAt() > syncDataTimestamp) {
        logger->warn("Ignoring changes to {}, more recent data is available {} < {}", local->subject(), syncDataTimestamp, local->syncedAt());
        return;
    }
    logger->info("ðŸ”¸ Updating message {}={} with subject: {}", local->remoteUID(), remote->uid(), local->subject());
    
    {
        MailStoreTransaction transaction{store};

        auto updated = MessageAttributesForMessage(remote);
        local->setUnread(updated.unread);
        local->setStarred(updated.starred);
        local->setDraft(updated.draft);
        local->setSyncedAt(syncDataTimestamp);
        local->setRemoteUID(updated.uid);
        local->setRemoteFolder(&folder);
        local->setClientFolder(&folder);
        auto jlabels = json(updated.labels);
        local->setRemoteXGMLabels(jlabels);
        
        // Save the message - this will automatically find and update the counters
        // on the thread we just created. Kind of a shame to find it twice but oh well.
        store->save(local);

        transaction.commit();
    }
}

void MailProcessor::retrievedMessageBody(Message * message, MessageParser * parser) {
    CleanHTMLBodyRendererTemplateCallback * callback = new CleanHTMLBodyRendererTemplateCallback();
    String * html = parser->htmlRendering(callback);
    String * text = html->flattenHTML()->stripWhitespace();
    MC_SAFE_RELEASE(callback);

    // build file containers for the attachments and write them to disk
    Array attachments = Array();
    attachments.addObjectsFromArray(parser->attachments());
    attachments.addObjectsFromArray(parser->htmlInlineAttachments());
    
    vector<File> files;
    for (int ii = 0; ii < attachments.count(); ii ++) {
        Attachment * a = (Attachment *)attachments.objectAtIndex(ii);
        File f = File(message, a);
        
        bool duplicate = false;
        for (auto & other : files) {
            if (other.partId() == string(a->partID()->UTF8Characters())) {
                duplicate = true;
                logger->info("Attachment is duplicate: {}", f.toJSON().dump());
                break;
            }
        }
        if (!duplicate) {
            if (!retrievedFileData(&f, a->data())) {
                logger->info("Could not save file data!");
            }
            files.push_back(f);
        }
    }
    
    auto chars = html->UTF8Characters();
    
    {
        MailStoreTransaction transaction{store};
        
        // write body to the MessageBodies table
        SQLite::Statement insert(store->db(), "REPLACE INTO MessageBody (id, value) VALUES (?, ?)");
        insert.bind(1, message->id());
        insert.bind(2, chars);
        insert.exec();
        
        // write files to the files table
        for (auto & file : files) {
            store->save(&file);
        }
        
        // append the body text to the thread's FTS5 search index
        auto thread = store->find<Thread>(Query().equal("id", message->threadId()));
        if (thread.get() != nullptr) {
            appendToThreadSearchContent(thread.get(), nullptr, text);
        }

        // write the message snippet. This also gives us the database trigger!
        message->setSnippet(text->substringToIndex(400)->UTF8Characters());
        message->setBodyForDispatch(chars);
        message->setFiles(files);
        
        store->save(message);
        
        transaction.commit();
    }
}


bool MailProcessor::retrievedFileData(File * file, Data * data) {
    string root = string(getenv("CONFIG_DIR_PATH")) + "/files";
    string path = MailUtils::pathForFile(root, file, true);
    String mfilepath = String(path.c_str());
    return (data->writeToFile(&mfilepath) == ErrorNone);
}

void MailProcessor::unlinkMessagesFromFolder(Folder & folder, vector<uint32_t> & uids, int phase)
{
    logger->info("Unlinking {} messages no longer present in remote range.", uids.size());
    
    {
        MailStoreTransaction transaction{store};
    
        for (vector<uint32_t> chunk : MailUtils::chunksOfVector(uids, 250)) {
            Query qd = Query().equal("remoteFolderId", folder.id()).equal("remoteUID", chunk);
            auto deletedMsgs = store->findAll<Message>(qd);

            for (const auto local : deletedMsgs) {
                local->setRemoteUID(UINT32_MAX - phase);
                store->save(local.get());
            }
        }

        transaction.commit();
    }
}

void MailProcessor::deleteMessagesStillUnlinkedFromPhase(int phase)
{
    {
        MailStoreTransaction transaction{store};
        
        auto q = Query().equal("accountId", account->id()).equal("remoteUID", UINT32_MAX - phase);
        auto messages = store->findAll<Message>(q);
        for (auto const & msg : messages) {
            store->remove(msg.get());
        }
        
        transaction.commit();
    }
}

void MailProcessor::appendToThreadSearchContent(Thread * thread, Message * messageToAppendOrNull, String * bodyToAppendOrNull) {
    string categories;
    for (auto f : thread->folders()) {
        categories += ((f.count("role") ? f["role"] : f["path"]).get<string>());
        categories += " ";
    }
    for (auto f : thread->labels()) {
        categories += ((f.count("role") ? f["role"] : f["path"]).get<string>());
        categories += " ";
    }
    
    // retrieve the current index if there is one
    
    string to;
    string from;
    string body = thread->subject();
    
    if (thread->searchRowId()) {
        SQLite::Statement existing(store->db(), "SELECT to_, from_, body FROM ThreadSearch WHERE rowid = ?");
        existing.bind(1, (double)thread->searchRowId());
        if (existing.executeStep()) {
            to = existing.getColumn("to_").getString();
            from = existing.getColumn("from_").getString();
            body = existing.getColumn("body").getString();
        }
    }
    
    if (messageToAppendOrNull != nullptr) {
        for (auto c : messageToAppendOrNull->to()) {
            if (c.count("email")) { to = to + " " + c["email"].get<string>(); }
            if (c.count("name")) { to = to + " " + c["name"].get<string>(); }
        }
        for (auto c : messageToAppendOrNull->cc()) {
            if (c.count("email")) { to = to + " " + c["email"].get<string>(); }
            if (c.count("name")) { to = to + " " + c["name"].get<string>(); }
        }
        for (auto c : messageToAppendOrNull->bcc()) {
            if (c.count("email")) { to = to + " " + c["email"].get<string>(); }
            if (c.count("name")) { to = to + " " + c["name"].get<string>(); }
        }
        for (auto c : messageToAppendOrNull->from()) {
            if (c.count("email")) { from = from + " " + c["email"].get<string>(); }
            if (c.count("name")) { from = from + " " + c["name"].get<string>(); }
        }
    }
    
    if (bodyToAppendOrNull != nullptr) {
        body = body + " " + bodyToAppendOrNull->substringToIndex(5000)->UTF8Characters();
    }
    
    if (thread->searchRowId()) {
        SQLite::Statement update(store->db(), "UPDATE ThreadSearch SET to_ = ?, from_ = ?, body = ?, categories = ? WHERE rowid = ?");
        update.bind(1, to);
        update.bind(2, from);
        update.bind(3, body);
        update.bind(4, categories);
        update.bind(5, (double)thread->searchRowId());
        update.exec();
    } else {
        SQLite::Statement insert(store->db(), "INSERT INTO ThreadSearch (to_, from_, body, categories, content_id) VALUES (?, ?, ?, ?, ?)");
        insert.bind(1, to);
        insert.bind(2, from);
        insert.bind(3, body);
        insert.bind(4, categories);
        insert.bind(5, thread->id());
        insert.exec();
        thread->setSearchRowId(store->db().getLastInsertRowid());
    }
}

void MailProcessor::upsertThreadReferences(string threadId, string accountId, string headerMessageId, Array * references) {
    string qmarks(MailUtils::qmarkSets(1 + references->count(), 3));
    SQLite::Statement query(store->db(), "INSERT OR IGNORE INTO ThreadReference (threadId, accountId, headerMessageId) VALUES " + qmarks);
    int x = 1;
    query.bind(x++, threadId);
    query.bind(x++, accountId);
    query.bind(x++, headerMessageId);
    for (int i = 0; i < references->count(); i ++) {
        String * address = (String*)references->objectAtIndex(i);
        query.bind(x++, threadId);
        query.bind(x++, accountId);
        query.bind(x++, address->UTF8Characters());
    }
    query.exec();
}

void MailProcessor::upsertContacts(Message * message) {
    map<string, json> byEmail{};
    for (auto & c : message->to()) {
        if (c.count("email")) {
            byEmail[MailUtils::contactKeyForEmail(c["email"].get<string>())] = c;
        }
    }
    for (auto & c : message->cc()) {
        if (c.count("email")) {
            byEmail[MailUtils::contactKeyForEmail(c["email"].get<string>())] = c;
        }
    }
    for (auto & c : message->from()) {
        if (c.count("email")) {
            byEmail[MailUtils::contactKeyForEmail(c["email"].get<string>())] = c;
        }
    }
    
    // contactKeyForEmail returns "" for some emails. Toss out that item
    if (byEmail.count("")) {
        byEmail.erase("");
    }
    
    vector<string> emails{};
    for (auto const& imap: byEmail) {
        emails.push_back(imap.first);
    }

    if (emails.size() > 25) {
        // I think it's safe to say mass emails shouldn't create contacts.
        return;
    }

    Query query = Query().equal("email", emails);
    auto results = store->findAll<Contact>(query);
    bool incrementCounters = message->isSentByUser();
    
    for (auto & result : results) {
        // update refcounts of existing items if this is a sent message
        if (incrementCounters) {
            result->incrementRefs();
            store->save(result.get(), false);
        }
        byEmail.erase(result->email());
    }
    
    if (byEmail.size() == 0) {
        return;
    }

    SQLite::Statement searchInsert(store->db(), "INSERT INTO ContactSearch (content_id, content) VALUES (?, ?)");

    for (auto & result : byEmail) {
        // insert remaining items
        Contact c{message->accountId(), result.first, result.second};
        if (incrementCounters) {
            c.incrementRefs();
        }
        store->save(&c, false);
        
        // also index for search
        searchInsert.bind(1, c.id());
        searchInsert.bind(2, c.searchContent());
        searchInsert.exec();
        searchInsert.reset();
    }
}

