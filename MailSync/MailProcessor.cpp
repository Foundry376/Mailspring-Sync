//
//  MailProcessor.cpp
//  MailSync
//
//  Created by Ben Gotow on 6/20/17.
//  Copyright Â© 2017 Foundry 376. All rights reserved.
//

#include "MailProcessor.hpp"
#include "MailUtils.hpp"
#include "File.hpp"

using namespace std;
using nlohmann::json;

MailProcessor::MailProcessor(string name, MailStore * store) :
    store(store),
    logger(spdlog::stdout_color_mt(name))
{

}

void MailProcessor::insertFallbackToUpdateMessage(IMAPMessage * mMsg, Folder & folder) {
    try {
        insertMessage(mMsg, folder);
    } catch (const SQLite::Exception & ex) {
        store->rollbackTransaction();
        Query q = Query().equal("id", MailUtils::idForMessage(mMsg));
        auto localMessage = store->find<Message>(q);
        if (localMessage.get() != nullptr) {
            updateMessage(localMessage.get(), mMsg, folder);
        } else {
            throw ex;
        }
    }
}

void MailProcessor::insertMessage(IMAPMessage * mMsg, Folder & folder) {
    Message msg(mMsg, folder);

    logger->info("ðŸ”¹ Inserting message with subject: {}", msg.subject());

    Array * references = mMsg->header()->references();
    if (references == nullptr) {
        references = new Array();
        references->autorelease();
    }
    shared_ptr<Thread> thread;
    auto allLabels = store->allLabelsCache();

    store->beginTransaction();

    // Find the correct thread

    if (mMsg->gmailThreadID()) {
        Query query = Query().equal("gThrId", to_string(mMsg->gmailThreadID()));
        thread = store->find<Thread>(query);
        
    } else if (!mMsg->header()->isMessageIDAutoGenerated()) {
        // find an existing thread using the references
        SQLite::Statement tQuery(store->db(), "SELECT Thread.* FROM Thread INNER JOIN ThreadReference ON ThreadReference.threadId = Thread.id WHERE ThreadReference.headerMessageId IN (" + MailUtils::qmarks(1 + references->count()) + ") LIMIT 1");
        tQuery.bind(1, msg.headerMessageId());
        for (int i = 0; i < references->count(); i ++) {
            String * ref = (String *)references->objectAtIndex(i);
            tQuery.bind(2 + i, ref->UTF8Characters());
        }
        if (tQuery.executeStep()) {
            thread = make_shared<Thread>(tQuery);
        }
    }
    
    // Add the message to the thread

    if (thread != nullptr) {
        thread->addMessage(&msg, allLabels);
    } else {
        thread = make_shared<Thread>(msg, mMsg->gmailThreadID(), allLabels);
    }
    
    // Apply changes to ThreadReferences, ThreadSearch, Contacts
    upsertThreadReferences(thread->id(), msg.headerMessageId(), references);
    appendToThreadSearchContent(thread.get(), &msg, nullptr);
    upsertContacts(&msg);
    
    store->save(thread.get());
    msg.setThreadId(thread->id());
    store->save(&msg);

    store->commitTransaction();
}

// thread has many folderIds with a reference count
// when message is moved, subtract + add to folder ref counts?
// keep in JSON?

// TODO: The JS side is clearing attributes placed in the JSON by the native side. Not cool

void MailProcessor::updateMessage(Message * local, IMAPMessage * remote, Folder & folder)
{
    logger->info("ðŸ”¸ Updating message with subject: {}", local->subject());

    store->beginTransaction();

    // Step 1: Find the thread
    Query query = Query().equal("id", local->threadId());
    auto thread = store->find<Thread>(query);
    auto allLabels = store->allLabelsCache();

    // Step 2: Decrement starred / unread / label counters on thread
    thread->prepareToReaddMessage(local, allLabels);
    
    // Step 3: Update the message
    auto updated = MessageAttributesForMessage(remote);
    local->setUnread(updated.unread);
    local->setStarred(updated.starred);
    local->setFolderImapUID(updated.uid);
    local->setFolder(folder);
    auto jlabels = json(updated.labels);
    local->setFolderImapXGMLabels(jlabels);
    
    // Step 4: Increment starred / urnead / label counters on thread
    thread->addMessage(local, allLabels);
    
    // Step 5: Save
    store->save(local);
    store->save(thread.get());

    // Step 6: Update categories listed in the FTS5 table
    appendToThreadSearchContent(thread.get(), nullptr, nullptr);
    
    store->commitTransaction();
}

void MailProcessor::retrievedMessageBody(Message * message, MessageParser * parser) {
    String * text = parser->plainTextBodyRendering(true);
    String * html = parser->htmlBodyRendering();
    
    // build file containers for the attachments
    Array * attachments = parser->attachments();
    vector<File> files;
    for (int ii = 0; ii < attachments->count(); ii ++) {
        Attachment * a = (Attachment *)attachments->objectAtIndex(ii);
        File f = File(message, a);
        
        bool duplicate = false;
        for (auto & other : files) {
            if (other.id() == f.id()) {
                duplicate = true;
                logger->info("Attachment is duplicate: {}", f.toJSON().dump());
                break;
            }
        }
        if (!duplicate) {
            files.push_back(f);
        }
    }
    
    auto chars = html->UTF8Characters();
    
    store->beginTransaction();
    
    // write body to the MessageBodies table
    SQLite::Statement insert(store->db(), "REPLACE INTO MessageBody (id, value) VALUES (?, ?)");
    insert.bind(1, message->id());
    insert.bind(2, chars);
    insert.exec();
    
    // write files to the files table
    for (auto & file : files) {
        store->save(&file);
    }
    
    // append the body text to the thread's FTS5 search index
    auto thread = store->find<Thread>(Query().equal("id", message->threadId()));
    if (thread.get() != nullptr) {
        appendToThreadSearchContent(thread.get(), nullptr, text);
    }

    // write the message snippet. This also gives us the database trigger!
    message->setSnippet(text->substringToIndex(400)->UTF8Characters());
    message->setBodyForDispatch(chars);
    message->setFiles(files);
    
    store->save(message);
    store->commitTransaction();
}

void MailProcessor::unlinkMessagesFromFolder(vector<shared_ptr<Message>> localMessages)
{
    // TODO Unloop
    auto allLabels = store->allLabelsCache();
    Folder gone("--none--", "", 0);
    
    vector<string> threadIds{};
    for (const auto local : localMessages) {
        threadIds.push_back(local->threadId());
    }
    
    auto q = Query().equal("id", threadIds);
    auto threads = store->findAllMap<Thread>(q, "id");

    for (const auto local : localMessages) {
        // Step 1: Find the thread
        Thread * thread = nullptr;
        if (threads.count(local->threadId())) {
            thread = threads[local->threadId()].get();
        }

        // Step 2: Decrement starred / unread / label counters on thread
        if (thread) { thread->prepareToReaddMessage(local.get(), allLabels); }

        local->setFolderImapUID(0);
        local->setFolder(gone);

        // Step 4: Increment starred / urnead / label counters on thread
        if (thread) { thread->addMessage(local.get(), allLabels); }
        
        // Step 5: Save
        store->save(local.get());

        if (thread) { store->save(thread); }
    }
}

void MailProcessor::appendToThreadSearchContent(Thread * thread, Message * messageToAppendOrNull, String * bodyToAppendOrNull) {
    string categories;
    for (auto f : thread->folders()) {
        categories += ((f.count("role") ? f["role"] : f["path"]).get<string>());
        categories += " ";
    }
    for (auto f : thread->labels()) {
        categories += ((f.count("role") ? f["role"] : f["path"]).get<string>());
        categories += " ";
    }

    // retrieve the current index if there is one
    
    string to;
    string from;
    string body = thread->subject();

    if (thread->searchRowId()) {
        SQLite::Statement existing(store->db(), "SELECT to_, from_, body FROM ThreadSearch WHERE rowid = ?");
        existing.bind(1, (double)thread->searchRowId());
        if (existing.executeStep()) {
            to = existing.getColumn("to_").getString();
            from = existing.getColumn("from_").getString();
            body = existing.getColumn("body").getString();
        }
    }
    
    if (messageToAppendOrNull != nullptr) {
        for (auto c : messageToAppendOrNull->to()) {
            if (c.count("email")) { to = to + " " + c["email"].get<string>(); }
            if (c.count("name")) { to = to + " " + c["name"].get<string>(); }
        }
        for (auto c : messageToAppendOrNull->cc()) {
            if (c.count("email")) { to = to + " " + c["email"].get<string>(); }
            if (c.count("name")) { to = to + " " + c["name"].get<string>(); }
        }
        for (auto c : messageToAppendOrNull->bcc()) {
            if (c.count("email")) { to = to + " " + c["email"].get<string>(); }
            if (c.count("name")) { to = to + " " + c["name"].get<string>(); }
        }
        for (auto c : messageToAppendOrNull->from()) {
            if (c.count("email")) { from = from + " " + c["email"].get<string>(); }
            if (c.count("name")) { from = from + " " + c["name"].get<string>(); }
        }
    }
    
    if (bodyToAppendOrNull != nullptr) {
        body = body + " " + bodyToAppendOrNull->substringToIndex(5000)->UTF8Characters();
    }
    
    if (thread->searchRowId()) {
        SQLite::Statement update(store->db(), "UPDATE ThreadSearch SET to_ = ?, from_ = ?, body = ?, categories = ? WHERE rowid = ?");
        update.bind(1, to);
        update.bind(2, from);
        update.bind(3, body);
        update.bind(4, categories);
        update.bind(5, (double)thread->searchRowId());
        update.exec();
    } else {
        SQLite::Statement insert(store->db(), "INSERT INTO ThreadSearch (to_, from_, body, categories, content_id) VALUES (?, ?, ?, ?, ?)");
        insert.bind(1, to);
        insert.bind(2, from);
        insert.bind(3, body);
        insert.bind(4, categories);
        insert.bind(5, thread->id());
        insert.exec();
        thread->setSearchRowId(store->db().getLastInsertRowid());
    }
}

void MailProcessor::upsertThreadReferences(string threadId, string headerMessageId, Array * references) {
    string qmarks(MailUtils::qmarkSets(1 + references->count(), 2));
    SQLite::Statement query(store->db(), "INSERT OR IGNORE INTO ThreadReference (threadId, headerMessageId) VALUES " + qmarks);
    int x = 1;
    query.bind(x++, threadId);
    query.bind(x++, headerMessageId);
    for (int i = 0; i < references->count(); i ++) {
        String * address = (String*)references->objectAtIndex(i);
        query.bind(x++, threadId);
        query.bind(x++, address->UTF8Characters());
    }
    query.exec();
}

void MailProcessor::upsertContacts(Message * message) {
    map<string, json> byEmail{};
    for (auto & c : message->to()) {
        if (c.count("email")) {
            byEmail[MailUtils::contactKeyForEmail(c["email"].get<string>())] = c;
        }
    }
    for (auto & c : message->cc()) {
        if (c.count("email")) {
            byEmail[MailUtils::contactKeyForEmail(c["email"].get<string>())] = c;
        }
    }
    for (auto & c : message->from()) {
        if (c.count("email")) {
            byEmail[MailUtils::contactKeyForEmail(c["email"].get<string>())] = c;
        }
    }
    
    // contactKeyForEmail returns "" for some emails. Toss out that item
    if (byEmail.count("")) {
        byEmail.erase("");
    }
    
    vector<string> emails{};
    for (auto const& imap: byEmail) {
        emails.push_back(imap.first);
    }

    // TODO ENSURE LENGTH < 500
    Query query = Query().equal("email", emails);
    auto results = store->findAll<Contact>(query);
    for (auto & result : results) {
        // update refcounts of existing items
        result->incrementRefs();
        store->save(result.get());
        byEmail.erase(result->email());
    }
    
    if (byEmail.size() == 0) {
        return;
    }

    SQLite::Statement searchInsert(store->db(), "INSERT INTO ContactSearch (content_id, content) VALUES (?, ?)");

    for (auto & result : byEmail) {
        // insert remaining items
        Contact c{message->accountId(), result.first, result.second};
        store->save(&c);
        
        // also index for search
        searchInsert.bind(1, c.id());
        searchInsert.bind(2, c.searchContent());
        searchInsert.exec();
        searchInsert.reset();
    }
}

